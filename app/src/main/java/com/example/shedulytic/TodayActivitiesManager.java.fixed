package com.example.shedulytic;

import android.content.Context;
import android.content.SharedPreferences;
import android.util.Log;
import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.toolbox.JsonObjectRequest;
import com.android.volley.toolbox.Volley;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

public class TodayActivitiesManager {
    private static final String TAG = "TodayActivitiesManager";
    private final Context context;
    private final TodayActivitiesListener listener;
    private final RequestQueue requestQueue;
    private final String userId;

    public interface TodayActivitiesListener {
        void onActivitiesLoaded(List<TaskItem> activities);
        void onUserProfileLoaded(String name, int streakCount, String avatarUrl);
        void onStreakDataLoaded(Map<String, Boolean> streakData);
        void onError(String message);
    }

    public TodayActivitiesManager(Context context, String userId, TodayActivitiesListener listener) {
        this.context = context;
        this.userId = userId;
        this.listener = listener;
        this.requestQueue = Volley.newRequestQueue(context);

        // Load user profile data when initialized
        loadUserProfile();
        
        // Load streak data for calendar
        loadStreakData();
    }
    
    /**
     * Loads streak data for the calendar display
     */
    public void loadStreakData() {
        if (userId == null || userId.isEmpty()) {
            Log.e(TAG, "Cannot load streak data: User ID is null or empty");
            listener.onError("User ID is not available");
            return;
        }
        
        // Check if network is available
        if (!IpV4Connection.isNetworkAvailable(context)) {
            Log.e(TAG, "Cannot load streak data: Network is unavailable");
            // Use cached data if available
            useDefaultStreakData();
            return;
        }
        
        // Calculate date range for streak data (last 30 days)
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
        Date today = new Date();
        Date startDate = new Date(today.getTime() - 29 * 24 * 60 * 60 * 1000L); // 30 days ago
        
        String startDateStr = dateFormat.format(startDate);
        String endDateStr = dateFormat.format(today);
        
        // Build the URL for streak data
        String url = IpV4Connection.getBaseUrl() + "phpfiles/get_user_streak_new.php";
        url += "?user_id=" + userId + "&start_date=" + startDateStr + "&end_date=" + endDateStr;
        
        Log.d(TAG, "Loading streak data from URL: " + url);
        
        // Use NetworkUtils for better error handling
        NetworkUtils.makeGetRequest(context, url, new NetworkUtils.JsonResponseCallback() {
            @Override
            public void onSuccess(JSONObject response) {
                // Dump the entire response for debugging
                Log.d(TAG, "Full streak response: " + response.toString());
                
                // Use the method to process streak data
                processStreakData(response, startDateStr, endDateStr);
            }
            
            @Override
            public void onError(String errorMessage) {
                Log.e(TAG, "Network error loading streak data: " + errorMessage);
                // Try fallback URL
                tryFallbackForStreakData(startDateStr, endDateStr);
            }
        });
    }
    
    /**
     * Try fallback URL for streak data
     */
    private void tryFallbackForStreakData(String startDate, String endDate) {
        // Use a fallback URL that correctly points to the phpfiles directory
        String fallbackUrl = IpV4Connection.getFallbackUrl();
        
        // Ensure the URL ends with a slash
        if (!fallbackUrl.endsWith("/")) {
            fallbackUrl += "/";
        }
        
        fallbackUrl += "phpfiles/get_user_streak.php?user_id=" + userId 
                   + "&start_date=" + startDate + "&end_date=" + endDate;
        // Log the fallback URL for debugging
        Log.d(TAG, "Using fallback URL for streak data: " + fallbackUrl);
        
        // Use NetworkUtils for better error handling
        NetworkUtils.makeGetRequest(context, fallbackUrl, new NetworkUtils.JsonResponseCallback() {
            @Override
            public void onSuccess(JSONObject response) {
                Log.d(TAG, "Fallback streak data response: " + response.toString().substring(0, Math.min(500, response.toString().length())));
                
                // Use the method to process streak data
                processStreakData(response, startDate, endDate);
            }
            
            @Override
            public void onError(String errorMessage) {
                Log.e(TAG, "Fallback network error for streak data: " + errorMessage);
                // Create default streak data (all false)
                createDefaultStreakData(startDate, endDate);
            }
        });
    }
    
    /**
     * Creates default streak data when server data is unavailable
     */
    private void createDefaultStreakData(String startDate, String endDate) {
        try {
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
            Date start = dateFormat.parse(startDate);
            Date end = dateFormat.parse(endDate);
            Map<String, Boolean> streakMap = new HashMap<>();
            
            if (start != null && end != null) {
                Calendar calendar = Calendar.getInstance();
                calendar.setTime(start);
                
                while (!calendar.getTime().after(end)) {
                    String date = dateFormat.format(calendar.getTime());
                    
                    // Mark today as active for better user experience
                    boolean isToday = date.equals(getCurrentDate());
                    streakMap.put(date, isToday);
                    
                    calendar.add(Calendar.DAY_OF_MONTH, 1);
                }
            }
            
            // Notify listener
            listener.onStreakDataLoaded(streakMap);
            
            // Also update the streak count in SharedPreferences
            SharedPreferences prefs = context.getSharedPreferences("UserPrefs", Context.MODE_PRIVATE);
            int cachedStreakCount = prefs.getInt("streak_count", 0);
            String username = prefs.getString("username", "User");
            String avatarUrl = prefs.getString("avatar_url", "");
            listener.onUserProfileLoaded(username, cachedStreakCount, avatarUrl);
            
        } catch (Exception e) {
            Log.e(TAG, "Error creating default streak data: " + e.getMessage(), e);
        }
    }
    
    /**
     * Uses default streak data from SharedPreferences when network is unavailable
     */
    private void useDefaultStreakData() {
        Log.d(TAG, "Using default streak data from SharedPreferences");
        
        // Calculate date range for streak data (last 30 days)
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
        Date today = new Date();
        Date startDate = new Date(today.getTime() - 29 * 24 * 60 * 60 * 1000L); // 30 days ago
        
        String startDateStr = dateFormat.format(startDate);
        String endDateStr = dateFormat.format(today);
        
        // Create default streak data
        createDefaultStreakData(startDateStr, endDateStr);
    }
    
    /**
     * Process streak data from JSON response with enhanced error handling
     * This method handles different response formats from the server
     */
    private void processStreakData(JSONObject response, String startDateStr, String endDateStr) {
        try {
            Map<String, Boolean> streakMap = new HashMap<>();
            int streakCount = 0;
            
            if (response.has("status") && response.getString("status").equals("success")) {
                // Try to get streak count
                if (response.has("streak_count")) {
                    streakCount = response.getInt("streak_count");
                    Log.d(TAG, "Found streak count: " + streakCount);
                }
                
                // Process streak data array
                if (response.has("streak_data")) {
                    JSONArray streakDataArray = response.getJSONArray("streak_data");
                    Log.d(TAG, "Processing streak_data array with " + streakDataArray.length() + " entries");
                    
                    for (int i = 0; i < streakDataArray.length(); i++) {
                        JSONObject dayData = streakDataArray.getJSONObject(i);
                        
                        // Extract date from various possible fields
                        String date = null;
                        if (dayData.has("date")) {
                            date = dayData.getString("date");
                        } else if (dayData.has("completion_date")) {
                            date = dayData.getString("completion_date");
                        }
                        
                        if (date != null) {
                            boolean hasActivity = false;
                            
                            // Determine if there was activity on this date
                            if (dayData.has("has_activity")) {
                                hasActivity = dayData.getBoolean("has_activity");
                            } else if (dayData.has("count")) {
                                hasActivity = dayData.getInt("count") > 0;
                            }
                            
                            Log.d(TAG, "Date: " + date + ", Has Activity: " + hasActivity);
                            streakMap.put(date, hasActivity);
                        }
                    }
                } else {
                    Log.w(TAG, "Response missing 'streak_data' key");
                    createDefaultStreakData(startDateStr, endDateStr);
                    return;
                }
            } else {
                Log.e(TAG, "Error in streak data response: " + response.optString("message", "Unknown error"));
                createDefaultStreakData(startDateStr, endDateStr);
                return;
            }
            
            // Update SharedPreferences
            SharedPreferences prefs = context.getSharedPreferences("UserPrefs", Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = prefs.edit();
            editor.putInt("streak_count", streakCount);
            editor.apply();
            
            // Notify listener
            listener.onStreakDataLoaded(streakMap);
            
            // Also update the UI with the streak count
            String username = prefs.getString("username", "User");
            String avatarUrl = prefs.getString("avatar_url", "");
            listener.onUserProfileLoaded(username, streakCount, avatarUrl);
            
        } catch (Exception e) {
            Log.e(TAG, "Error processing streak data: " + e.getMessage(), e);
            createDefaultStreakData(startDateStr, endDateStr);
        }
    }
    
    /**
     * Get current date in yyyy-MM-dd format
     */
    private String getCurrentDate() {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
        return dateFormat.format(new Date());
    }
    
    /**
     * Load user profile data including name, streak count, and avatar URL
     */
    public void loadUserProfile() {
        if (userId == null || userId.isEmpty()) {
            Log.e(TAG, "Cannot load user profile: User ID is null or empty");
            listener.onError("User ID is not available");
            return;
        }
        
        // Check if network is available
        if (!IpV4Connection.isNetworkAvailable(context)) {
            Log.e(TAG, "Cannot load user profile: Network is unavailable");
            // Use cached data if available
            useDefaultUserProfile();
            return;
        }
        
        // Build the URL for user profile
        String url = IpV4Connection.getBaseUrl() + "phpfiles/get_user_profile.php";
        url += "?user_id=" + userId;
        
        Log.d(TAG, "Loading user profile from URL: " + url);
        
        // Use NetworkUtils for better error handling
        NetworkUtils.makeGetRequest(context, url, new NetworkUtils.JsonResponseCallback() {
            @Override
            public void onSuccess(JSONObject response) {
                try {
                    if (response.has("status") && response.getString("status").equals("success")) {
                        String username = "User";
                        int streakCount = 0;
                        String avatarUrl = "";
                        
                        if (response.has("data")) {
                            JSONObject data = response.getJSONObject("data");
                            
                            if (data.has("username")) {
                                username = data.getString("username");
                            }
                            
                            if (data.has("streak_count")) {
                                streakCount = data.getInt("streak_count");
                            }
                            
                            if (data.has("avatar_url")) {
                                avatarUrl = data.getString("avatar_url");
                            }
                        }
                        
                        // Update SharedPreferences
                        SharedPreferences prefs = context.getSharedPreferences("UserPrefs", Context.MODE_PRIVATE);
                        SharedPreferences.Editor editor = prefs.edit();
                        editor.putString("username", username);
                        editor.putInt("streak_count", streakCount);
                        editor.putString("avatar_url", avatarUrl);
                        editor.apply();
                        
                        // Notify listener
                        listener.onUserProfileLoaded(username, streakCount, avatarUrl);
                    } else {
                        Log.e(TAG, "Error in user profile response: " + response.optString("message", "Unknown error"));
                        useDefaultUserProfile();
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Error processing user profile: " + e.getMessage(), e);
                    useDefaultUserProfile();
                }
            }
            
            @Override
            public void onError(String errorMessage) {
                Log.e(TAG, "Network error loading user profile: " + errorMessage);
                useDefaultUserProfile();
            }
        });
    }
    
    /**
     * Use default user profile from SharedPreferences
     */
    private void useDefaultUserProfile() {
        SharedPreferences prefs = context.getSharedPreferences("UserPrefs", Context.MODE_PRIVATE);
        String username = prefs.getString("username", "User");
        int streakCount = prefs.getInt("streak_count", 0);
        String avatarUrl = prefs.getString("avatar_url", "");
        
        listener.onUserProfileLoaded(username, streakCount, avatarUrl);
    }
    
    public void loadTodayActivities() {
        // Check if network is available
        if (!IpV4Connection.isNetworkAvailable(context)) {
            listener.onError("Network unavailable. Please check your connection.");
            return;
        }

        // Initialize NetworkUtils for better error handling
        NetworkUtils.initialize(context);
        
        String url = IpV4Connection.getTodayTasksUrl(userId, getCurrentDate());
        Log.d(TAG, "Loading today's activities from URL: " + url);
        
        // Use NetworkUtils for robust error handling and automatic fallback
        NetworkUtils.makeGetRequest(context, url, new NetworkUtils.JsonResponseCallback() {
            @Override
            public void onSuccess(JSONObject response) {
                try {
                    Log.d(TAG, "Response received: " + response.toString().substring(0, Math.min(500, response.toString().length())));
                    
                    // Check for different response formats
                    JSONArray tasksArray = null;
                    if (response.has("tasks")) {
                        tasksArray = response.getJSONArray("tasks");
                    } else if (response.has("data") && response.getJSONObject("data").has("tasks")) {
                        tasksArray = response.getJSONObject("data").getJSONArray("tasks");
                    }
                    
                    if (tasksArray != null && tasksArray.length() > 0) {
                        List<TaskItem> activities = new ArrayList<>();

                        for (int i = 0; i < tasksArray.length(); i++) {
                            JSONObject task = tasksArray.getJSONObject(i);
                            String title = task.optString("title", "Untitled Task");
                            String startTime = task.optString("start_time", "00:00:00");
                            String endTime = task.optString("end_time", "00:00:00");
                            String taskType = task.optString("task_type", "workflow");
                            String taskId = task.optString("task_id", "0");
                            boolean isCompleted = task.optInt("is_completed", 0) == 1 || 
                                                task.optString("status", "").equals("completed");

                            TaskItem taskItem = new TaskItem(
                                title,
                                formatTimeRange(startTime, endTime),
                                calculateDuration(startTime, endTime),
                                taskType
                            );
                            taskItem.setId(taskId);
                            taskItem.setCompleted(isCompleted);
                            
                            // Set streak count if available
                            if (task.has("streak") || task.has("streak_count")) {
                                int streak = task.optInt("streak", task.optInt("streak_count", 0));
                                taskItem.setStreak(streak);
                            }
                            
                            activities.add(taskItem);
                        }
                        listener.onActivitiesLoaded(activities);
                    } else if (response.has("status") && response.getString("status").equals("error")) {
                        String errorMessage = response.optString("message", "Unknown error");
                        Log.e(TAG, "Server returned error: " + errorMessage);
                        listener.onError("Server error: " + errorMessage);
                    } else {
                        Log.d(TAG, "No tasks found for today");
                        // Return empty list with a "No tasks" message
                        List<TaskItem> emptyList = new ArrayList<>();
                        TaskItem noTasksItem = new TaskItem(
                            "No tasks scheduled for today",
                            "",
                            "Add a task to get started",
                            "info"
                        );
                        emptyList.add(noTasksItem);
                        listener.onActivitiesLoaded(emptyList);
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Error parsing tasks: " + e.getMessage(), e);
                    listener.onError("Error loading tasks. Please try again.");
                }
            }
            
            @Override
            public void onError(String errorMessage) {
                Log.e(TAG, "Network error loading activities: " + errorMessage);
                listener.onError("Network error: " + errorMessage);
            }
        });
    }
    
    /**
     * Format time range for display (e.g., "9:00 AM - 10:30 AM")
     */
    private String formatTimeRange(String startTime, String endTime) {
        try {
            SimpleDateFormat inputFormat = new SimpleDateFormat("HH:mm:ss", Locale.getDefault());
            SimpleDateFormat outputFormat = new SimpleDateFormat("h:mm a", Locale.getDefault());
            
            Date startDate = inputFormat.parse(startTime);
            Date endDate = inputFormat.parse(endTime);
            
            if (startDate != null && endDate != null) {
                return outputFormat.format(startDate) + " - " + outputFormat.format(endDate);
            }
        } catch (Exception e) {
            Log.e(TAG, "Error formatting time range: " + e.getMessage(), e);
        }
        
        return startTime + " - " + endTime;
    }
    
    /**
     * Calculate duration between start and end times (e.g., "1h 30m")
     */
    private String calculateDuration(String startTime, String endTime) {
        try {
            SimpleDateFormat format = new SimpleDateFormat("HH:mm:ss", Locale.getDefault());
            Date startDate = format.parse(startTime);
            Date endDate = format.parse(endTime);
            
            if (startDate != null && endDate != null) {
                long durationMillis = endDate.getTime() - startDate.getTime();
                long hours = durationMillis / (60 * 60 * 1000);
                long minutes = (durationMillis % (60 * 60 * 1000)) / (60 * 1000);
                
                if (hours > 0) {
                    return hours + "h " + (minutes > 0 ? minutes + "m" : "");
                } else {
                    return minutes + "m";
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "Error calculating duration: " + e.getMessage(), e);
        }
        
        return "";
    }
}
